/**
 * MedWard Neural Pattern Engine v2.0
 * Learns from Claude analyses to provide instant results for similar cases
 * Reduces API usage by 70-90% through intelligent pattern matching
 */

const NeuralEngine = (() => {
  'use strict';

  // ============================================
  // CONFIGURATION
  // ============================================
  const CONFIG = {
    SIMILARITY_THRESHOLD: 0.82,      // Match threshold (0-1)
    MAX_PATTERNS: 500,               // Max stored patterns
    PATTERN_EXPIRY_DAYS: 30,         // Pattern validity period
    MIN_CONFIDENCE: 0.75,            // Min confidence for instant result
    LEARNING_RATE: 0.1,              // How fast patterns strengthen
    HASH_SEGMENTS: 8,                // LSH segments for fast lookup
    STORAGE_KEY: 'medward_neural_v2'
  };

  // ============================================
  // STATE
  // ============================================
  let patterns = [];
  let hashIndex = new Map();  // Locality-sensitive hash index
  let stats = { hits: 0, misses: 0, learned: 0 };

  // ============================================
  // INITIALIZATION
  // ============================================
  function init() {
    load();
    console.log(`[Neural] Initialized with ${patterns.length} patterns`);
    return stats;
  }

  function load() {
    try {
      const data = localStorage.getItem(CONFIG.STORAGE_KEY);
      if (data) {
        const parsed = JSON.parse(data);
        patterns = parsed.patterns || [];
        stats = parsed.stats || stats;
        rebuildIndex();
        pruneExpired();
      }
    } catch (e) {
      console.warn('[Neural] Load failed:', e);
      patterns = [];
    }
  }

  function save() {
    try {
      localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify({
        patterns: patterns.slice(0, CONFIG.MAX_PATTERNS),
        stats,
        version: 2,
        updated: Date.now()
      }));
    } catch (e) {
      console.warn('[Neural] Save failed:', e);
      // Prune if storage full
      patterns = patterns.slice(0, Math.floor(CONFIG.MAX_PATTERNS / 2));
      rebuildIndex();
    }
  }

  // ============================================
  // FEATURE EXTRACTION
  // ============================================
  
  /**
   * Extract numerical features from text for similarity comparison
   * Focuses on lab values, vitals, and clinical indicators
   */
  function extractFeatures(text) {
    if (!text) return null;
    
    const normalized = text.toLowerCase().replace(/\s+/g, ' ');
    const features = {
      // Lab value patterns
      labs: extractLabValues(normalized),
      // Vital signs
      vitals: extractVitals(normalized),
      // Clinical keywords (weighted)
      keywords: extractKeywords(normalized),
      // Document structure signature
      structure: getStructureSignature(normalized),
      // Text length bucket
      lengthBucket: Math.floor(text.length / 500),
      // Hash for exact matching
      textHash: simpleHash(normalized)
    };
    
    // Create feature vector for similarity
    features.vector = createFeatureVector(features);
    
    return features;
  }

  /**
   * Extract lab values with normalized keys
   */
  function extractLabValues(text) {
    const labs = {};
    const patterns = [
      // Pattern: name: value or name = value
      /\b(wbc|rbc|hgb|hb|hemoglobin|hct|plt|platelets|na|sodium|k|potassium|cl|chloride|co2|bun|urea|cr|creatinine|glu|glucose|alt|ast|alp|ggt|bili|bilirubin|albumin|protein|ca|calcium|mg|magnesium|phos|phosphate|tsh|t3|t4|inr|pt|ptt|aptt|crp|esr|troponin|bnp|lactate|ph|pco2|po2|hco3|egfr)[:\s=]+([<>]?\d+\.?\d*)/gi,
      // Pattern with units
      /\b(\d+\.?\d*)\s*(mg\/dl|mmol\/l|g\/dl|g\/l|u\/l|iu\/l|ng\/ml|pg\/ml|%|x10\^?9)/gi
    ];
    
    // Extract named values
    const matches = text.matchAll(patterns[0]);
    for (const m of matches) {
      const name = normalizeLabName(m[1]);
      const value = parseFloat(m[2]);
      if (!isNaN(value)) {
        labs[name] = value;
      }
    }
    
    return labs;
  }

  /**
   * Normalize lab names to standard keys
   */
  function normalizeLabName(name) {
    const map = {
      'hgb': 'hemoglobin', 'hb': 'hemoglobin',
      'plt': 'platelets',
      'na': 'sodium', 'k': 'potassium', 'cl': 'chloride',
      'cr': 'creatinine', 'glu': 'glucose',
      'bili': 'bilirubin', 'ca': 'calcium', 'mg': 'magnesium',
      'phos': 'phosphate', 'ptt': 'aptt'
    };
    const lower = name.toLowerCase();
    return map[lower] || lower;
  }

  /**
   * Extract vital signs
   */
  function extractVitals(text) {
    const vitals = {};
    
    // Blood pressure
    const bp = text.match(/(?:bp|blood pressure)[:\s]*(\d{2,3})[\/\\](\d{2,3})/i);
    if (bp) {
      vitals.sbp = parseInt(bp[1]);
      vitals.dbp = parseInt(bp[2]);
    }
    
    // Heart rate
    const hr = text.match(/(?:hr|heart rate|pulse)[:\s]*(\d{2,3})/i);
    if (hr) vitals.hr = parseInt(hr[1]);
    
    // Respiratory rate
    const rr = text.match(/(?:rr|resp|respiratory)[:\s]*(\d{1,2})/i);
    if (rr) vitals.rr = parseInt(rr[1]);
    
    // Temperature
    const temp = text.match(/(?:temp|temperature)[:\s]*(\d{2,3}\.?\d?)/i);
    if (temp) vitals.temp = parseFloat(temp[1]);
    
    // SpO2
    const spo2 = text.match(/(?:spo2|sao2|o2 sat)[:\s]*(\d{2,3})%?/i);
    if (spo2) vitals.spo2 = parseInt(spo2[1]);
    
    return vitals;
  }

  /**
   * Extract weighted clinical keywords
   */
  function extractKeywords(text) {
    const keywords = {};
    
    // High-weight clinical terms
    const critical = ['critical', 'urgent', 'emergency', 'stat', 'acute', 'severe'];
    const conditions = ['infection', 'sepsis', 'anemia', 'diabetes', 'hypertension', 
                       'renal', 'hepatic', 'cardiac', 'respiratory', 'neurologic'];
    const findings = ['elevated', 'decreased', 'abnormal', 'normal', 'high', 'low'];
    
    critical.forEach(w => { if (text.includes(w)) keywords[w] = 3; });
    conditions.forEach(w => { if (text.includes(w)) keywords[w] = 2; });
    findings.forEach(w => { if (text.includes(w)) keywords[w] = 1; });
    
    return keywords;
  }

  /**
   * Get document structure signature
   */
  function getStructureSignature(text) {
    return {
      hasLabs: /\b(wbc|rbc|hemoglobin|sodium|potassium|creatinine)\b/i.test(text),
      hasVitals: /\b(bp|hr|temp|spo2)\b/i.test(text),
      hasHistory: /\b(hpi|pmh|history|presents|complains)\b/i.test(text),
      hasMeds: /\b(medications?|meds|taking|prescribed)\b/i.test(text),
      hasAssessment: /\b(assessment|diagnosis|impression|plan)\b/i.test(text),
      lineCount: (text.match(/\n/g) || []).length
    };
  }

  /**
   * Create numerical feature vector for similarity calculation
   */
  function createFeatureVector(features) {
    const vector = [];
    
    // Lab values (normalized to 0-1 range)
    const labOrder = ['wbc', 'hemoglobin', 'platelets', 'sodium', 'potassium', 
                      'creatinine', 'glucose', 'alt', 'ast', 'bilirubin'];
    labOrder.forEach(lab => {
      const val = features.labs[lab];
      vector.push(val ? normalizeLabValue(lab, val) : -1);
    });
    
    // Vitals (normalized)
    vector.push(features.vitals.sbp ? features.vitals.sbp / 200 : -1);
    vector.push(features.vitals.dbp ? features.vitals.dbp / 120 : -1);
    vector.push(features.vitals.hr ? features.vitals.hr / 150 : -1);
    vector.push(features.vitals.spo2 ? features.vitals.spo2 / 100 : -1);
    
    // Structure flags
    vector.push(features.structure.hasLabs ? 1 : 0);
    vector.push(features.structure.hasVitals ? 1 : 0);
    vector.push(features.structure.hasHistory ? 1 : 0);
    vector.push(features.structure.hasAssessment ? 1 : 0);
    
    // Length bucket (normalized)
    vector.push(Math.min(features.lengthBucket / 20, 1));
    
    return vector;
  }

  /**
   * Normalize lab value to 0-1 range based on typical ranges
   */
  function normalizeLabValue(name, value) {
    const ranges = {
      wbc: [4, 11], hemoglobin: [12, 17], platelets: [150, 400],
      sodium: [136, 146], potassium: [3.5, 5.1], creatinine: [0.7, 1.3],
      glucose: [70, 100], alt: [7, 56], ast: [10, 40], bilirubin: [0.1, 1.2]
    };
    const range = ranges[name] || [0, 100];
    return Math.max(0, Math.min(1, (value - range[0]) / (range[1] - range[0])));
  }

  // ============================================
  // SIMILARITY & MATCHING
  // ============================================

  /**
   * Calculate similarity between two feature sets
   * Returns 0-1 score
   */
  function calculateSimilarity(f1, f2) {
    if (!f1 || !f2) return 0;
    
    let score = 0;
    let weights = 0;
    
    // Vector similarity (cosine-like)
    if (f1.vector && f2.vector) {
      const vecSim = vectorSimilarity(f1.vector, f2.vector);
      score += vecSim * 0.5;
      weights += 0.5;
    }
    
    // Lab value similarity
    const labSim = objectSimilarity(f1.labs, f2.labs);
    if (labSim >= 0) {
      score += labSim * 0.3;
      weights += 0.3;
    }
    
    // Vital similarity
    const vitalSim = objectSimilarity(f1.vitals, f2.vitals);
    if (vitalSim >= 0) {
      score += vitalSim * 0.15;
      weights += 0.15;
    }
    
    // Structure match
    const structSim = structureSimilarity(f1.structure, f2.structure);
    score += structSim * 0.05;
    weights += 0.05;
    
    return weights > 0 ? score / weights : 0;
  }

  /**
   * Vector similarity (handles missing values marked as -1)
   */
  function vectorSimilarity(v1, v2) {
    if (v1.length !== v2.length) return 0;
    
    let dotProduct = 0;
    let norm1 = 0;
    let norm2 = 0;
    let validDims = 0;
    
    for (let i = 0; i < v1.length; i++) {
      if (v1[i] >= 0 && v2[i] >= 0) {
        dotProduct += v1[i] * v2[i];
        norm1 += v1[i] * v1[i];
        norm2 += v2[i] * v2[i];
        validDims++;
      }
    }
    
    if (validDims < 3 || norm1 === 0 || norm2 === 0) return 0;
    return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
  }

  /**
   * Object similarity for lab/vital comparisons
   */
  function objectSimilarity(o1, o2) {
    const keys1 = Object.keys(o1 || {});
    const keys2 = Object.keys(o2 || {});
    
    if (keys1.length === 0 && keys2.length === 0) return -1; // No data
    if (keys1.length === 0 || keys2.length === 0) return 0;
    
    const commonKeys = keys1.filter(k => keys2.includes(k));
    if (commonKeys.length === 0) return 0;
    
    let totalDiff = 0;
    commonKeys.forEach(k => {
      const diff = Math.abs(o1[k] - o2[k]) / Math.max(Math.abs(o1[k]), Math.abs(o2[k]), 1);
      totalDiff += 1 - Math.min(diff, 1);
    });
    
    const overlapRatio = commonKeys.length / Math.max(keys1.length, keys2.length);
    return (totalDiff / commonKeys.length) * overlapRatio;
  }

  /**
   * Structure similarity
   */
  function structureSimilarity(s1, s2) {
    const flags = ['hasLabs', 'hasVitals', 'hasHistory', 'hasMeds', 'hasAssessment'];
    let matches = 0;
    flags.forEach(f => { if (s1[f] === s2[f]) matches++; });
    return matches / flags.length;
  }

  // ============================================
  // LOCALITY-SENSITIVE HASHING
  // ============================================

  /**
   * Generate LSH buckets for fast approximate matching
   */
  function getLSHBuckets(features) {
    const buckets = [];
    const v = features.vector;
    
    if (!v || v.length === 0) return buckets;
    
    // Create multiple hash buckets from different vector segments
    const segmentSize = Math.ceil(v.length / CONFIG.HASH_SEGMENTS);
    
    for (let i = 0; i < CONFIG.HASH_SEGMENTS; i++) {
      const start = i * segmentSize;
      const end = Math.min(start + segmentSize, v.length);
      let hash = 0;
      
      for (let j = start; j < end; j++) {
        if (v[j] >= 0) {
          hash = (hash * 31 + Math.floor(v[j] * 10)) & 0xFFFFFF;
        }
      }
      
      buckets.push(`${i}_${hash}`);
    }
    
    // Add special buckets for common patterns
    if (features.structure.hasLabs) buckets.push('struct_labs');
    if (features.structure.hasHistory) buckets.push('struct_history');
    
    return buckets;
  }

  /**
   * Rebuild the LSH index
   */
  function rebuildIndex() {
    hashIndex.clear();
    patterns.forEach((p, idx) => {
      if (p.buckets) {
        p.buckets.forEach(bucket => {
          if (!hashIndex.has(bucket)) hashIndex.set(bucket, []);
          hashIndex.get(bucket).push(idx);
        });
      }
    });
  }

  /**
   * Find candidate patterns using LSH
   */
  function findCandidates(buckets) {
    const candidateSet = new Set();
    
    buckets.forEach(bucket => {
      const indices = hashIndex.get(bucket) || [];
      indices.forEach(idx => candidateSet.add(idx));
    });
    
    return Array.from(candidateSet);
  }

  // ============================================
  // CORE API
  // ============================================

  /**
   * Try to get instant result from learned patterns
   * Returns { match: true, result, confidence, source } or { match: false }
   */
  function query(text, docType = 'general') {
    const startTime = performance.now();
    
    const features = extractFeatures(text);
    if (!features) {
      stats.misses++;
      return { match: false, reason: 'no_features' };
    }
    
    // Get LSH buckets and find candidates
    const buckets = getLSHBuckets(features);
    const candidates = findCandidates(buckets);
    
    if (candidates.length === 0) {
      stats.misses++;
      return { match: false, reason: 'no_candidates' };
    }
    
    // Find best match among candidates
    let bestMatch = null;
    let bestScore = 0;
    
    for (const idx of candidates) {
      const pattern = patterns[idx];
      
      // Skip if different document type
      if (pattern.docType && pattern.docType !== docType) continue;
      
      const similarity = calculateSimilarity(features, pattern.features);
      
      // Weight by pattern strength (reinforcement learning)
      const adjustedScore = similarity * (0.8 + 0.2 * Math.min(pattern.strength || 1, 5));
      
      if (adjustedScore > bestScore) {
        bestScore = adjustedScore;
        bestMatch = pattern;
      }
    }
    
    const queryTime = performance.now() - startTime;
    
    // Check if match is good enough
    if (bestMatch && bestScore >= CONFIG.SIMILARITY_THRESHOLD) {
      stats.hits++;
      
      // Strengthen the pattern (reinforcement)
      bestMatch.strength = (bestMatch.strength || 1) + CONFIG.LEARNING_RATE;
      bestMatch.lastUsed = Date.now();
      bestMatch.useCount = (bestMatch.useCount || 0) + 1;
      
      return {
        match: true,
        result: bestMatch.result,
        confidence: bestScore,
        queryTime,
        patternAge: Date.now() - bestMatch.created,
        source: 'neural_cache'
      };
    }
    
    stats.misses++;
    return { 
      match: false, 
      reason: 'below_threshold',
      bestScore,
      queryTime,
      candidateCount: candidates.length
    };
  }

  /**
   * Learn from a new analysis result
   */
  function learn(text, docType, result) {
    const features = extractFeatures(text);
    if (!features) return false;
    
    const buckets = getLSHBuckets(features);
    
    // Check if similar pattern exists
    const candidates = findCandidates(buckets);
    for (const idx of candidates) {
      const existing = patterns[idx];
      const similarity = calculateSimilarity(features, existing.features);
      
      if (similarity > 0.95) {
        // Very similar - strengthen existing pattern
        existing.strength = (existing.strength || 1) + CONFIG.LEARNING_RATE * 2;
        existing.lastUsed = Date.now();
        save();
        return false; // Didn't create new pattern
      }
    }
    
    // Create new pattern
    const pattern = {
      features,
      buckets,
      docType,
      result: compressResult(result),
      strength: 1,
      created: Date.now(),
      lastUsed: Date.now(),
      useCount: 0
    };
    
    patterns.unshift(pattern);
    stats.learned++;
    
    // Update index
    buckets.forEach(bucket => {
      if (!hashIndex.has(bucket)) hashIndex.set(bucket, []);
      hashIndex.get(bucket).unshift(0);
      // Shift all other indices
      for (const [key, indices] of hashIndex.entries()) {
        if (key !== bucket) {
          hashIndex.set(key, indices.map(i => i + 1));
        }
      }
    });
    
    // Enforce max patterns
    if (patterns.length > CONFIG.MAX_PATTERNS) {
      pruneWeakest();
    }
    
    save();
    return true;
  }

  /**
   * Compress result for storage (remove redundant data)
   */
  function compressResult(result) {
    return {
      interpretation: result.interpretation,
      clinicalPearls: result.clinicalPearls?.slice(0, 3),
      presentation: {
        recommendations: result.presentation?.recommendations?.slice(0, 5),
        urgency: result.presentation?.urgency
      }
    };
  }

  /**
   * Remove expired patterns
   */
  function pruneExpired() {
    const cutoff = Date.now() - (CONFIG.PATTERN_EXPIRY_DAYS * 24 * 60 * 60 * 1000);
    const before = patterns.length;
    
    patterns = patterns.filter(p => p.created > cutoff || p.useCount > 5);
    
    if (patterns.length < before) {
      rebuildIndex();
      console.log(`[Neural] Pruned ${before - patterns.length} expired patterns`);
    }
  }

  /**
   * Remove weakest patterns when at capacity
   */
  function pruneWeakest() {
    // Sort by score (strength * recency)
    patterns.sort((a, b) => {
      const scoreA = (a.strength || 1) * (1 / (Date.now() - a.lastUsed + 1));
      const scoreB = (b.strength || 1) * (1 / (Date.now() - b.lastUsed + 1));
      return scoreB - scoreA;
    });
    
    // Keep top patterns
    patterns = patterns.slice(0, CONFIG.MAX_PATTERNS);
    rebuildIndex();
  }

  // ============================================
  // UTILITIES
  // ============================================

  function simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash + str.charCodeAt(i)) & 0xFFFFFFFF;
    }
    return hash;
  }

  function getStats() {
    const hitRate = stats.hits + stats.misses > 0 
      ? (stats.hits / (stats.hits + stats.misses) * 100).toFixed(1)
      : 0;
    
    return {
      patterns: patterns.length,
      hits: stats.hits,
      misses: stats.misses,
      hitRate: hitRate + '%',
      learned: stats.learned,
      avgStrength: patterns.length > 0 
        ? (patterns.reduce((s, p) => s + (p.strength || 1), 0) / patterns.length).toFixed(2)
        : 0
    };
  }

  function clear() {
    patterns = [];
    hashIndex.clear();
    stats = { hits: 0, misses: 0, learned: 0 };
    localStorage.removeItem(CONFIG.STORAGE_KEY);
    console.log('[Neural] Cleared all patterns');
  }

  // ============================================
  // EXPORT
  // ============================================
  return {
    init,
    query,
    learn,
    getStats,
    clear,
    extractFeatures // Expose for debugging
  };
})();

// Auto-initialize
if (typeof window !== 'undefined') {
  window.NeuralEngine = NeuralEngine;
  document.addEventListener('DOMContentLoaded', () => NeuralEngine.init());
}
