/**
 * MedWard Master - Backend API v3.0
 * Google Apps Script - OPTIMIZED FOR SPEED
 * 
 * SETUP:
 * 1. Go to script.google.com → New Project
 * 2. Paste this code
 * 3. Click ⚙️ Project Settings → Script Properties → Add:
 *    - ANTHROPIC_API_KEY = your_key
 * 4. Deploy → New Deployment → Web App
 *    - Execute as: Me
 *    - Access: Anyone
 * 5. Copy the URL to your app
 */

// ═══════════════════════════════════════════════════════════
// CONFIGURATION - OPTIMIZED FOR SPEED
// ═══════════════════════════════════════════════════════════
const CONFIG = {
  // Claude Haiku 4.5 - Fastest model, great for medical analysis
  CLAUDE_MODEL: 'claude-haiku-4-5-20251001',
  MAX_TOKENS: 2000,
  TEMPERATURE: 0.3,  // Lower = faster, more consistent
  
  // Timeouts
  API_TIMEOUT: 25000,  // 25 seconds max
  
  // Feature flags
  SKIP_ARCHIVING: true,  // Skip Drive archiving for speed
  ENABLE_LOGGING: false  // Disable logging for speed
};

// ═══════════════════════════════════════════════════════════
// MAIN ENTRY POINTS
// ═══════════════════════════════════════════════════════════

function doPost(e) {
  const startTime = Date.now();
  
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;
    
    let response;
    
    switch(action) {
      case 'interpret':
      case 'analyzeImage':
      case 'analyze':
        response = handleAnalysis(data);
        break;
      case 'extractPatients':
        response = handlePatientExtraction(data);
        break;
      case 'extractMedicalData':
        response = handleExtractMedicalData(data);
        break;
      case 'login':
        response = { success: true, token: Utilities.getUuid(), user: { username: data.username || 'Doctor' }};
        break;
      default:
        response = { success: false, error: 'Unknown action: ' + action };
    }
    
    // Add timing info
    response.processingTime = Date.now() - startTime;
    
    return ContentService.createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.toString(),
      processingTime: Date.now() - startTime
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

function doGet(e) {
  return ContentService.createTextOutput(JSON.stringify({
    status: 'MedWard API v3.0 - Online',
    model: CONFIG.CLAUDE_MODEL,
    features: ['Vision Analysis', 'Lab Interpretation', 'Neural Integration']
  })).setMimeType(ContentService.MimeType.JSON);
}

// ═══════════════════════════════════════════════════════════
// MAIN ANALYSIS HANDLER - UNIFIED & FAST
// ═══════════════════════════════════════════════════════════

function handleAnalysis(data) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('ANTHROPIC_API_KEY');
  
  if (!apiKey) {
    return { success: false, error: 'API key not configured. Add ANTHROPIC_API_KEY to Script Properties.' };
  }
  
  // Determine input type
  const hasImage = data.image || data.imageData || data.base64Full;
  const hasText = data.text || data.textContent || data.content;
  const docType = data.documentType || data.imageType || 'general';
  const context = data.clinicalContext || data.context || '';
  
  try {
    if (hasImage) {
      // IMAGE ANALYSIS - Single call for speed
      return analyzeImageDirect(apiKey, data, docType, context);
    } else if (hasText) {
      // TEXT ANALYSIS
      const text = data.text || data.textContent || data.content;
      return analyzeText(apiKey, text, docType, context);
    } else {
      return { success: false, error: 'No image or text provided' };
    }
  } catch (error) {
    return { success: false, error: 'Analysis failed: ' + error.toString() };
  }
}

// ═══════════════════════════════════════════════════════════
// IMAGE ANALYSIS - SINGLE OPTIMIZED CALL
// ═══════════════════════════════════════════════════════════

function analyzeImageDirect(apiKey, data, docType, context) {
  // Handle multiple images or single image
  var images = data.images || [];
  var singleImage = data.image || data.imageData || data.base64Full;
  
  // Build content array
  var contentArray = [];
  
  if (images.length > 0) {
    // Multiple images
    for (var i = 0; i < images.length; i++) {
      var imgData = images[i].data || images[i];
      var parsed = parseImageData(imgData);
      if (parsed) {
        contentArray.push({
          type: 'image',
          source: {
            type: 'base64',
            media_type: parsed.mediaType,
            data: parsed.base64
          }
        });
      }
    }
  } else if (singleImage) {
    // Single image (backward compatible)
    var parsed = parseImageData(singleImage);
    if (parsed) {
      contentArray.push({
        type: 'image',
        source: {
          type: 'base64',
          media_type: parsed.mediaType,
          data: parsed.base64
        }
      });
    }
  }
  
  if (contentArray.length === 0) {
    return { success: false, error: 'No valid image data provided' };
  }
  
  // Add text prompt
  var prompt = buildUnifiedPrompt(docType, context);
  if (contentArray.length > 1) {
    prompt = 'You are analyzing ' + contentArray.length + ' medical images together. Provide a comprehensive combined analysis.\n\n' + prompt;
  }
  contentArray.push({ type: 'text', text: prompt });
  
  const requestPayload = {
    model: CONFIG.CLAUDE_MODEL,
    max_tokens: CONFIG.MAX_TOKENS,
    messages: [{
      role: 'user',
      content: contentArray
    }]
  };
  
  const response = UrlFetchApp.fetch('https://api.anthropic.com/v1/messages', {
    method: 'post',
    headers: {
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'content-type': 'application/json'
    },
    payload: JSON.stringify(requestPayload),
    muteHttpExceptions: true
  });
  
  const result = JSON.parse(response.getContentText());
  
  if (result.error) {
    return { success: false, error: 'Claude API Error: ' + (result.error.message || JSON.stringify(result.error)) };
  }
  
  const aiResponse = result.content && result.content[0] && result.content[0].text;
  
  if (!aiResponse) {
    return { success: false, error: 'No response from Claude' };
  }
  
  // Parse the structured response
  return parseUnifiedResponse(aiResponse);
}

// Helper to parse image data URL or raw base64
function parseImageData(imageSource) {
  if (!imageSource || typeof imageSource !== 'string') return null;
  
  let base64Data = null;
  let mediaType = 'image/jpeg';
  
  if (imageSource.startsWith('data:')) {
    const match = imageSource.match(/data:([^;]+);base64,(.+)/);
    if (match) {
      mediaType = match[1];
      base64Data = match[2];
    }
  } else {
    base64Data = imageSource;
  }
  
  if (!base64Data) return null;
  
  // Clean base64
  base64Data = base64Data.replace(/\s+/g, '').replace(/%20/g, '').replace(/[\r\n]/g, '');
  
  return { base64: base64Data, mediaType: mediaType };
}

// ═══════════════════════════════════════════════════════════
// TEXT ANALYSIS
// ═══════════════════════════════════════════════════════════

function analyzeText(apiKey, text, docType, context) {
  const prompt = `Analyze this ${docType} medical report and provide a structured interpretation.

${context ? 'Clinical Context: ' + context + '\n\n' : ''}Report:
${text}

Respond with JSON:
{
  "interpretation": {
    "summary": "Brief 2-3 sentence overview",
    "keyFindings": ["Finding 1", "Finding 2", "Finding 3"],
    "abnormalities": ["Abnormal finding with value and clinical significance"],
    "normalFindings": ["Normal finding 1", "Normal finding 2"]
  },
  "clinicalPearls": ["Important clinical insight 1", "Pearl 2"],
  "potentialQuestions": ["Question for attending 1", "Question 2"],
  "presentation": {
    "patientFriendly": "Simple explanation for patient",
    "recommendations": ["Recommended action 1", "Action 2"]
  }
}`;

  const response = UrlFetchApp.fetch('https://api.anthropic.com/v1/messages', {
    method: 'post',
    headers: {
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'content-type': 'application/json'
    },
    payload: JSON.stringify({
      model: CONFIG.CLAUDE_MODEL,
      max_tokens: CONFIG.MAX_TOKENS,
      messages: [{ role: 'user', content: prompt }]
    }),
    muteHttpExceptions: true
  });
  
  const result = JSON.parse(response.getContentText());
  
  if (result.error) {
    return { success: false, error: 'Claude API Error: ' + result.error.message };
  }
  
  const aiResponse = result.content[0].text;
  return parseUnifiedResponse(aiResponse, text);
}

// ═══════════════════════════════════════════════════════════
// PATIENT LIST EXTRACTION - For Import Feature
// ═══════════════════════════════════════════════════════════

function handlePatientExtraction(data) {
  // Safety check for data parameter
  if (!data || typeof data !== 'object') {
    return { success: false, error: 'No data provided to handlePatientExtraction' };
  }
  
  const apiKey = PropertiesService.getScriptProperties().getProperty('ANTHROPIC_API_KEY');
  
  if (!apiKey) {
    return { success: false, error: 'API key not configured' };
  }
  
  // Extract base64 and media type - handle multiple input formats
  let base64Data = null;
  let mediaType = 'image/jpeg';
  
  // Try different possible image field names - with explicit checks
  let imageSource = '';
  if (data.image && typeof data.image === 'string') {
    imageSource = data.image;
  } else if (data.imageData && typeof data.imageData === 'string') {
    imageSource = data.imageData;
  } else if (data.base64 && typeof data.base64 === 'string') {
    imageSource = data.base64;
  } else if (data.base64Full && typeof data.base64Full === 'string') {
    imageSource = data.base64Full;
  }
  
  if (!imageSource || imageSource.length < 100) {
    return { success: false, error: 'No valid image data provided. Received keys: ' + Object.keys(data).join(', ') };
  }
  
  if (typeof imageSource === 'string' && imageSource.startsWith('data:')) {
    // Data URL format: data:image/jpeg;base64,/9j/4AAQ...
    const match = imageSource.match(/data:([^;]+);base64,(.+)/);
    if (match) {
      mediaType = match[1];
      base64Data = match[2];
    } else {
      return { success: false, error: 'Invalid data URL format' };
    }
  } else if (typeof imageSource === 'string') {
    // Raw base64 string
    base64Data = imageSource;
    mediaType = data.mimeType || data.mediaType || 'image/jpeg';
  } else {
    return { success: false, error: 'Unsupported image format' };
  }
  
  if (!base64Data) {
    return { success: false, error: 'Could not extract base64 data' };
  }
  
  // Clean base64 - remove whitespace and URL encoding artifacts
  base64Data = base64Data.replace(/\s+/g, '').replace(/%20/g, '').replace(/[\r\n]/g, '');
  
  const prompt = `You are a medical data extraction specialist. Analyze this image which contains a patient list (could be from Excel, Google Sheets, EMR system, handwritten notes, or any tabular format).

Extract ALL patient information you can find. For each patient, identify:
- Name (required)
- Room/Bed number  
- Diagnosis/Condition
- Status (classify as: critical, active, or chronic based on context clues)
- Attending physician/doctor if mentioned

Rules:
1. Extract EVERY patient visible in the image
2. If a field is unclear, make your best inference from context
3. For status: use "critical" for ICU, unstable, urgent cases; "chronic" for stable, follow-up cases; "active" for regular admissions
4. Clean up any OCR artifacts or formatting issues in names
5. Standardize room numbers (e.g., "21A" → "21-A")
6. If no diagnosis listed, use "Pending evaluation"
7. Look for Arabic/English text

Respond ONLY with a valid JSON object containing a "patients" array:
{"patients":[{"name":"Patient Name","room":"21-A","diagnosis":"Diagnosis here","status":"active","doctor":"Dr. Name"}]}

If you cannot find any patients, respond with: {"patients":[]}`;

  try {
    const response = UrlFetchApp.fetch('https://api.anthropic.com/v1/messages', {
      method: 'post',
      headers: {
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json'
      },
      payload: JSON.stringify({
        model: CONFIG.CLAUDE_MODEL,
        max_tokens: CONFIG.MAX_TOKENS,
        messages: [{
          role: 'user',
          content: [
            {
              type: 'image',
              source: {
                type: 'base64',
                media_type: mediaType,
                data: base64Data
              }
            },
            {
              type: 'text',
              text: prompt
            }
          ]
        }]
      }),
      muteHttpExceptions: true
    });
    
    const result = JSON.parse(response.getContentText());
    
    if (result.error) {
      return { success: false, error: 'Claude API Error: ' + (result.error.message || JSON.stringify(result.error)) };
    }
    
    const aiResponse = result.content && result.content[0] && result.content[0].text;
    
    if (!aiResponse) {
      return { success: false, error: 'No response from Claude' };
    }
    
    // Parse the JSON response
    let jsonStr = aiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    const jsonMatch = jsonStr.match(/\{[\s\S]*\}/);
    
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      return {
        success: true,
        patients: parsed.patients || [],
        extractedText: aiResponse
      };
    }
    
    // Try to find array directly
    const arrayMatch = jsonStr.match(/\[[\s\S]*\]/);
    if (arrayMatch) {
      const patients = JSON.parse(arrayMatch[0]);
      return {
        success: true,
        patients: patients,
        extractedText: aiResponse
      };
    }
    
    return {
      success: true,
      patients: [],
      extractedText: aiResponse,
      error: 'Could not parse patient data'
    };
    
  } catch (error) {
    return { success: false, error: 'Patient extraction failed: ' + error.toString() };
  }
}

// ═══════════════════════════════════════════════════════════
// MEDICAL DATA EXTRACTION (for rounds.html)
// ═══════════════════════════════════════════════════════════

function handleExtractMedicalData(data) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('ANTHROPIC_API_KEY');
  
  if (!apiKey) {
    return { success: false, error: 'API key not configured' };
  }
  
  let base64Data = data.imageData;
  let mediaType = data.mimeType || 'image/jpeg';
  
  if (!base64Data) {
    return { success: false, error: 'No image data' };
  }
  
  // Clean base64
  base64Data = base64Data.replace(/\s+/g, '');
  
  const prompt = data.prompt || `Extract all medical data from this image. Return JSON with:
{
  "patient": { "name": "", "mrn": "", "dob": "", "age": 0, "gender": "", "ward": "", "room": "", "bed": "" },
  "vitals": { "bp": "", "hr": "", "rr": "", "spo2": "", "temp": "", "gcs": "" },
  "labs": [{ "name": "", "value": "", "unit": "", "reference": "", "flag": "critical|high|low|normal", "date": "" }],
  "diagnoses": [],
  "problems": [],
  "medications": [{ "name": "", "dose": "", "frequency": "", "status": "active|held|stopped" }],
  "notes": "",
  "plan": [],
  "imaging": [{ "type": "", "date": "", "findings": [] }],
  "vbg": { "ph": "", "pco2": "", "hco3": "", "lactate": "", "k": "" }
}
Return ONLY valid JSON.`;

  const response = UrlFetchApp.fetch('https://api.anthropic.com/v1/messages', {
    method: 'post',
    headers: {
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'content-type': 'application/json'
    },
    payload: JSON.stringify({
      model: CONFIG.CLAUDE_MODEL,
      max_tokens: CONFIG.MAX_TOKENS,
      messages: [{
        role: 'user',
        content: [
          {
            type: 'image',
            source: { type: 'base64', media_type: mediaType, data: base64Data }
          },
          { type: 'text', text: prompt }
        ]
      }]
    }),
    muteHttpExceptions: true
  });
  
  const result = JSON.parse(response.getContentText());
  
  if (result.error) {
    return { success: false, error: result.error.message };
  }
  
  return {
    success: true,
    analysis: result.content[0].text
  };
}

// ═══════════════════════════════════════════════════════════
// OPTIMIZED PROMPTS
// ═══════════════════════════════════════════════════════════

function buildUnifiedPrompt(docType, context) {
  const typeHints = {
    'lab': 'laboratory results with test names, values, units, and flags (H/L/HH/LL)',
    'xray': 'X-ray/radiograph findings',
    'ct': 'CT or MRI scan findings',
    'ecg': 'ECG/EKG rhythm and findings',
    'pathology': 'pathology or histology report',
    'dermatology': 'skin lesion or dermatological findings',
    'ophthalmology': 'eye examination or fundoscopy',
    'general': 'medical document'
  };
  
  const typeHint = typeHints[docType] || typeHints['general'];
  
  return `Analyze this medical image (${typeHint}).

${context ? 'Clinical Context: ' + context + '\n\n' : ''}INSTRUCTIONS:
1. Extract ALL visible text, especially numerical values with their labels
2. Identify abnormal values (marked H, HH, L, LL, *, or outside reference ranges)
3. Provide clinical interpretation

Respond with this exact JSON structure:
{
  "extractedText": "Complete text extracted from image preserving format",
  "interpretation": {
    "summary": "2-3 sentence clinical summary",
    "keyFindings": ["Important finding 1", "Finding 2", "Finding 3"],
    "abnormalities": ["Abnormal: Value (significance)"],
    "normalFindings": ["Normal finding 1", "Normal 2"]
  },
  "clinicalPearls": ["Clinical insight 1", "Pearl 2"],
  "potentialQuestions": ["Question 1", "Question 2"],
  "presentation": {
    "patientFriendly": "Simple patient explanation",
    "recommendations": ["Action 1", "Action 2"],
    "urgency": "routine|urgent|emergent"
  }
}

Return ONLY valid JSON, no markdown or explanation.`;
}

// ═══════════════════════════════════════════════════════════
// RESPONSE PARSING
// ═══════════════════════════════════════════════════════════

function parseUnifiedResponse(aiResponse, originalText) {
  try {
    // Try to extract JSON from response
    let jsonStr = aiResponse;
    
    // Remove markdown code blocks if present
    jsonStr = jsonStr.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    // Find JSON object
    const jsonMatch = jsonStr.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      
      return {
        success: true,
        extractedText: parsed.extractedText || originalText || '',
        interpretation: parsed.interpretation || {
          summary: parsed.summary || 'Analysis complete',
          keyFindings: parsed.keyFindings || parsed.findings || [],
          abnormalities: parsed.abnormalities || [],
          normalFindings: parsed.normalFindings || []
        },
        clinicalPearls: parsed.clinicalPearls || [],
        potentialQuestions: parsed.potentialQuestions || [],
        presentation: parsed.presentation || {
          patientFriendly: parsed.patientFriendly || '',
          recommendations: parsed.recommendations || [],
          urgency: parsed.urgency || 'routine'
        },
        provider: 'claude',
        model: CONFIG.CLAUDE_MODEL
      };
    }
    
    // Fallback: return as plain text
    return {
      success: true,
      extractedText: aiResponse,
      interpretation: {
        summary: aiResponse.substring(0, 500),
        keyFindings: [],
        abnormalities: [],
        normalFindings: []
      },
      clinicalPearls: [],
      potentialQuestions: [],
      presentation: {
        patientFriendly: '',
        recommendations: [],
        urgency: 'routine'
      },
      provider: 'claude',
      model: CONFIG.CLAUDE_MODEL
    };
    
  } catch (error) {
    // Return raw response on parse error
    return {
      success: true,
      extractedText: aiResponse,
      interpretation: {
        summary: 'Analysis complete. See extracted text.',
        keyFindings: [],
        abnormalities: [],
        normalFindings: []
      },
      clinicalPearls: [],
      potentialQuestions: [],
      presentation: {
        patientFriendly: '',
        recommendations: [],
        urgency: 'routine'
      },
      provider: 'claude',
      parseError: error.toString()
    };
  }
}

// ═══════════════════════════════════════════════════════════
// TEST FUNCTIONS
// ═══════════════════════════════════════════════════════════

function testAPI() {
  const result = handleAnalysis({
    action: 'interpret',
    text: 'Hemoglobin: 8.5 g/dL (Low)\nWBC: 15.2 (High)\nPlatelets: 450,000\nCreatinine: 2.8 mg/dL (High)',
    documentType: 'lab'
  });
  Logger.log(JSON.stringify(result, null, 2));
}

function testConfig() {
  const apiKey = PropertiesService.getScriptProperties().getProperty('ANTHROPIC_API_KEY');
  Logger.log('API Key configured: ' + (apiKey ? 'Yes (' + apiKey.substring(0, 10) + '...)' : 'NO - Add ANTHROPIC_API_KEY to Script Properties'));
}
